<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MyInfixParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Calculator with JUnit5 and Cucumber tests</a> &gt; <a href="index.source.html" class="el_package">parser</a> &gt; <span class="el_source">MyInfixParser.java</span></div><h1>MyInfixParser.java</h1><pre class="source lang-java linenums">package parser;
import calculator.*;
import calculator.values.*;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

import static parser.MyInfixParser.Node.TWO_ARG_FUNCS;

/**
 * The MyInfixParser class provides functionality for parsing and evaluating
 * arithmetic expressions written in infix notation.
 *
 * Features:
 * - Supports integers, decimals, fractions (a/b), and complex numbers [a+bi]
 * - Recognizes trigonometric functions: sin(x), cos(x), tan(x)
 * - Allows scientific notation via E(x), equivalent to 10^x
 * - Supports fraction vs. decimal display modes
 * - Integrates with a shared Calculator instance for evaluation
 *
 * Author: Hugue
 */

<span class="nc" id="L25">public class MyInfixParser {</span>

    public static Double toDouble(String value) {
<span class="nc" id="L28">        return Double.parseDouble(value);</span>
    }

    /**
     * Represents a node in the expression tree.
     */
    public static class Node {
        public String value;
        public Node left;
        public Node right;
        public Node parent;
<span class="fc" id="L39">        public boolean isFunction = false;</span>
<span class="fc" id="L40">        public boolean isComplex = false;</span>
<span class="fc" id="L41">        public static final Set&lt;String&gt; TWO_ARG_FUNCS = Set.of(</span>
                &quot;root&quot;, &quot;power&quot;, &quot;log&quot;
        );


<span class="fc" id="L46">        public Node(String value) {</span>
<span class="fc" id="L47">            this.value = value;</span>
<span class="fc" id="L48">        }</span>

        public void setLeft(Node child) {
<span class="fc" id="L51">            this.left = child;</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">            if (child != null) {</span>
<span class="fc" id="L53">                child.parent = this;</span>
            }
<span class="fc" id="L55">        }</span>

        public void setRight(Node child) {
<span class="fc" id="L58">            this.right = child;</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">            if (child != null) {</span>
<span class="fc" id="L60">                child.parent = this;</span>
            }
<span class="fc" id="L62">        }</span>
    }

    /**
     * Builds an expression tree from an infix string expression.
     * @param expression the infix expression
     * @return root node of the expression tree
     */
    public static Node buildTree(String expression) {
<span class="fc" id="L71">        Stack&lt;Node&gt; nodes = new Stack&lt;&gt;();</span>
<span class="fc" id="L72">        Stack&lt;String&gt; ops = new Stack&lt;&gt;();</span>
<span class="fc" id="L73">        StringBuilder token = new StringBuilder();</span>
<span class="fc" id="L74">        boolean inBracket = false;</span>

<span class="fc" id="L76">        expression = expression.replaceAll(&quot;\\s+&quot;, &quot;&quot;);</span>
<span class="fc" id="L77">        int parenthesesBalance = 0;</span>

<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (int i = 0; i &lt; expression.length(); i++) {</span>
<span class="fc" id="L80">            char c = expression.charAt(i);</span>

            // 1) Reconnaître '-' unaire devant un nombre
<span class="pc bpc" id="L83" title="2 of 6 branches missed.">            boolean canBeUnaryMinus =</span>
                    !inBracket
                            &amp;&amp; c == '-'
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">                            &amp;&amp; (i == 0 || &quot;+-*/(&quot;.indexOf(expression.charAt(i - 1)) &gt;= 0)</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">                            &amp;&amp; (i + 1 &lt; expression.length())</span>
<span class="pc bnc" id="L88" title="All 4 branches missed.">                            &amp;&amp; (Character.isDigit(expression.charAt(i + 1)) || expression.charAt(i + 1) == '.');</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">            if (canBeUnaryMinus) {</span>
<span class="nc" id="L90">                token.append(c);</span>
<span class="nc" id="L91">                continue;</span>
            }

            // 2) Complexes [...]
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">            if (c == '[') {</span>
<span class="nc" id="L96">                inBracket = true;</span>
<span class="nc" id="L97">                token.append(c);</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">            } else if (c == ']') {</span>
<span class="nc" id="L99">                token.append(c);</span>
<span class="nc" id="L100">                inBracket = false;</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">            } else if (inBracket) {</span>
<span class="nc" id="L102">                token.append(c);</span>

                // 3) Chiffres, points, lettres (variables ou fonctions)
<span class="fc bfc" id="L105" title="All 6 branches covered.">            } else if (Character.isDigit(c) || c == '.' || Character.isLetter(c)) {</span>
<span class="fc" id="L106">                token.append(c);</span>

                // 4) Fin de token, on le pousse
            }
            // 4.bis) Séparateur d'arguments de fonction
<span class="fc bfc" id="L111" title="All 2 branches covered.">            else if (c == ',') {</span>
                // flush du token courant
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                if (token.length() &gt; 0) {</span>
<span class="fc" id="L114">                    String tok = token.toString();</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                    if (isFunctionName(tok)) ops.push(tok);</span>
<span class="fc" id="L116">                    else nodes.push(createNodeFromToken(tok));</span>
<span class="fc" id="L117">                    token.setLength(0);</span>
                }
                // on dépile tout jusqu'à la parenthèse ouvrante
<span class="pc bpc" id="L120" title="2 of 4 branches missed.">                while (!ops.isEmpty() &amp;&amp; !ops.peek().equals(&quot;(&quot;)) {</span>
<span class="nc" id="L121">                    buildSubTree(nodes, ops.pop());</span>
                }

// 4.ter) Pourcentage postfixe
<span class="fc bfc" id="L125" title="All 2 branches covered.">            } else if (c == '%') {</span>
                // flush du token courant (le nombre)
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">                if (token.length() &gt; 0) {</span>
<span class="fc" id="L128">                    nodes.push(createNodeFromToken(token.toString()));</span>
<span class="fc" id="L129">                    token.setLength(0);</span>
                }
                // on construit directement le nœud % comme une fonction unaire
<span class="fc" id="L132">                buildSubTree(nodes, &quot;%&quot;);</span>
            }
            else {
<span class="fc bfc" id="L135" title="All 2 branches covered.">                if (token.length() &gt; 0) {</span>
<span class="fc" id="L136">                    String tok = token.toString();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                    if (isFunctionName(tok)) ops.push(tok);</span>
<span class="fc" id="L138">                    else nodes.push(createNodeFromToken(tok));</span>
<span class="fc" id="L139">                    token.setLength(0);</span>
                }

                // 5) Parenthèses et opérateurs comme avant
<span class="fc bfc" id="L143" title="All 2 branches covered.">                if (c == '(') {</span>
<span class="fc" id="L144">                    ops.push(&quot;(&quot;);</span>
<span class="fc" id="L145">                    parenthesesBalance++;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">                } else if (c == ')') {</span>
<span class="fc" id="L147">                    parenthesesBalance--;</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">                    if (parenthesesBalance &lt; 0)</span>
<span class="fc" id="L149">                        throw new IllegalArgumentException(&quot;Parenthèse fermante sans ouvrante !&quot;);</span>

<span class="pc bpc" id="L151" title="1 of 4 branches missed.">                    while (!ops.isEmpty() &amp;&amp; !ops.peek().equals(&quot;(&quot;))</span>
<span class="fc" id="L152">                        buildSubTree(nodes, ops.pop());</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">                    if (ops.isEmpty())</span>
<span class="nc" id="L154">                        throw new IllegalArgumentException(&quot;Parenthèse ouvrante non trouvée pour fermer.&quot;);</span>
<span class="fc" id="L155">                    ops.pop();</span>

<span class="pc bpc" id="L157" title="1 of 4 branches missed.">                    if (!ops.isEmpty() &amp;&amp; isFunctionName(ops.peek()))</span>
<span class="fc" id="L158">                        buildSubTree(nodes, ops.pop());</span>

<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                } else if (isOperator(String.valueOf(c))) {</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">                    while (!ops.isEmpty()</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">                            &amp;&amp; precedence(ops.peek()) &gt;= precedence(String.valueOf(c)))</span>
<span class="nc" id="L163">                        buildSubTree(nodes, ops.pop());</span>
<span class="fc" id="L164">                    ops.push(String.valueOf(c));</span>

                } else {
<span class="nc" id="L167">                    throw new IllegalArgumentException(&quot;Caractère invalide détecté : &quot; + c);</span>
                }
            }
        }

        // Reste du flush et construction finale…
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (token.length() &gt; 0) {</span>
<span class="fc" id="L174">            String tok = token.toString();</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (isFunctionName(tok)) ops.push(tok);</span>
<span class="fc" id="L176">            else nodes.push(createNodeFromToken(tok));</span>
        }
<span class="fc bfc" id="L178" title="All 2 branches covered.">        while (!ops.isEmpty()) {</span>
<span class="fc" id="L179">            String op = ops.pop();</span>
<span class="pc bpc" id="L180" title="2 of 4 branches missed.">            if (op.equals(&quot;(&quot;) || op.equals(&quot;)&quot;))</span>
<span class="nc" id="L181">                throw new IllegalArgumentException(&quot;Parenthèses non fermées !&quot;);</span>
<span class="fc" id="L182">            buildSubTree(nodes, op);</span>
<span class="fc" id="L183">        }</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (nodes.size() != 1)</span>
<span class="nc" id="L185">            throw new IllegalStateException(&quot;Expression invalide : trop ou pas assez de noeuds.&quot;);</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (parenthesesBalance != 0)</span>
<span class="nc" id="L187">            throw new IllegalArgumentException(&quot;Parenthèses non équilibrées !&quot;);</span>

<span class="fc" id="L189">        return nodes.pop();</span>
    }

    /**
     * Constructs a subtree with the given operator and operands from the stack.
     * @param nodes stack of current nodes
     * @param op operator or function name
     */
    private static void buildSubTree(Stack&lt;Node&gt; nodes, String op) {
<span class="fc" id="L198">        Node parent = new Node(op);</span>

<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (isFunctionName(op)) {</span>
<span class="fc" id="L201">            parent.isFunction = true;</span>

<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (TWO_ARG_FUNCS.contains(op)) {</span>
                // fonctions à 2 arguments
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">                if (nodes.size() &lt; 2)</span>
<span class="nc" id="L206">                    throw new IllegalStateException(&quot;Pas assez d'arguments pour &quot; + op);</span>
<span class="fc" id="L207">                Node right = nodes.pop();</span>
<span class="fc" id="L208">                Node left  = nodes.pop();</span>
<span class="fc" id="L209">                parent.setLeft(left);</span>
<span class="fc" id="L210">                parent.setRight(right);</span>

<span class="fc" id="L212">            } else {</span>
                // fonctions unaires
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                if (nodes.isEmpty())</span>
<span class="nc" id="L215">                    throw new IllegalStateException(&quot;Pas d'argument pour la fonction &quot; + op);</span>
<span class="fc" id="L216">                Node child = nodes.pop();</span>
<span class="fc" id="L217">                parent.setLeft(child);</span>
<span class="fc" id="L218">            }</span>

        } else {
            // opérateur binaire standard
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            if (nodes.size() &lt; 2)</span>
<span class="nc" id="L223">                throw new IllegalStateException(&quot;Pas assez d'opérandes pour '&quot; + op + &quot;'&quot;);</span>
<span class="fc" id="L224">            Node right = nodes.pop();</span>
<span class="fc" id="L225">            Node left  = nodes.pop();</span>
<span class="fc" id="L226">            parent.setLeft(left);</span>
<span class="fc" id="L227">            parent.setRight(right);</span>
        }

<span class="fc" id="L230">        nodes.push(parent);</span>
<span class="fc" id="L231">    }</span>


    /**
     * Checks whether the string is a supported operator.
     * @param s token to check
     * @return true if it's an operator, false otherwise
     */
    private static boolean isOperator(String s) {
<span class="pc bpc" id="L240" title="1 of 8 branches missed.">        return s.equals(&quot;+&quot;) || s.equals(&quot;-&quot;) || s.equals(&quot;*&quot;) || s.equals(&quot;/&quot;);</span>
    }

    /**
     * Returns the precedence of the given operator.
     * @param op operator as a string
     * @return integer representing precedence level
     */
    private static int precedence(String op) {
<span class="pc bpc" id="L249" title="1 of 4 branches missed.">        if (op.equals(&quot;+&quot;) || op.equals(&quot;-&quot;)) return 1;</span>
<span class="pc bpc" id="L250" title="2 of 4 branches missed.">        if (op.equals(&quot;*&quot;) || op.equals(&quot;/&quot;)) return 2;</span>
<span class="fc" id="L251">        return 0;</span>
    }

    /**
     * Determines if a token is a supported function.
     * @param token token string
     * @return true if token is a function name, false otherwise
     */
    private static boolean isFunctionName(String token) {
<span class="pc bpc" id="L260" title="4 of 8 branches missed.">        return token.equals(&quot;sin&quot;) || token.equals(&quot;cos&quot;) || token.equals(&quot;tan&quot;) || token.equals(&quot;E&quot;)</span>
<span class="pc bpc" id="L261" title="2 of 8 branches missed.">                || token.equals(&quot;exp&quot;)|| token.equals(&quot;ln&quot;) || token.equals(&quot;log&quot;) || token.equals(&quot;sqrt&quot;)</span>
<span class="pc bpc" id="L262" title="2 of 8 branches missed.">                || token.equals(&quot;root&quot;) || token.equals(&quot;power&quot;) || token.equals(&quot;inv&quot;) || token.equals(&quot;%&quot;);</span>
    }

    /**
     * Creates a Node from a token, marking it as function or complex if appropriate.
     * @param token input token
     * @return a new Node
     */
    private static Node createNodeFromToken(String token) {
<span class="fc" id="L271">        Node node = new Node(token);</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (isFunctionName(token)) {</span>
<span class="nc" id="L273">            node.isFunction = true;</span>
<span class="pc bpc" id="L274" title="3 of 4 branches missed.">        } else if (token.startsWith(&quot;[&quot;) &amp;&amp; token.endsWith(&quot;]&quot;)) {</span>
<span class="nc" id="L275">            node.isComplex = true;</span>
        }
<span class="fc" id="L277">        return node;</span>
    }

    /**
     * Evaluates the expression tree.
     * @param root root of the tree
     * @return result as a NumericValue
     */
    public static NumericValue evaluate(Node root) throws IllegalConstruction {
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (root == null) {</span>
<span class="nc" id="L287">            throw new IllegalArgumentException(&quot;Nœud racine nul !&quot;);</span>
        }

        //System.out.println(&quot;Évaluation du nœud : &quot; + root.value);

<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (root.isFunction) {</span>
<span class="fc" id="L293">            Calculator c = ExpressionParser.mycalculator;</span>
            // si c’est une fonction binaire
<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (TWO_ARG_FUNCS.contains(root.value)) {</span>
<span class="fc" id="L296">                NumericValue a = evaluate(root.left);</span>
<span class="fc" id="L297">                NumericValue b = evaluate(root.right);</span>
<span class="pc bpc" id="L298" title="2 of 4 branches missed.">                switch (root.value) {</span>
                    case &quot;root&quot;:
<span class="nc" id="L300">                        Root r=new Root(List.of(new MyNumber(evaluate(root.left)),new MyNumber(evaluate(root.right))), Notation.INFIX);</span>
<span class="nc" id="L301">                        return new RealValue(Double.parseDouble(c.eval(r).toString()),10);</span>

                    case &quot;power&quot;:
<span class="fc" id="L304">                        Power p=new Power(List.of(new MyNumber(evaluate(root.left)),new MyNumber(evaluate(root.right))), Notation.INFIX);</span>
<span class="fc" id="L305">                        return new RealValue(Double.parseDouble(c.eval(p).toString()),10);</span>

                    case &quot;log&quot;:
<span class="fc" id="L308">                        Log log = new Log(List.of(new MyNumber(evaluate(root.left)),new MyNumber(evaluate(root.right))), Notation.INFIX);</span>
<span class="fc" id="L309">                        return new RealValue(Double.parseDouble(c.eval(log).toString()),10);</span>
                }
            }
            // sinon fonctions unaires restantes
<span class="pc bpc" id="L313" title="8 of 10 branches missed.">            switch (root.value) {</span>
                // Fonctions trigonométriques &amp; E déjà en place...
<span class="nc" id="L315">                case &quot;sin&quot;:   return new RealValue(c.sin  (toDouble(root.left.value)), 10);</span>
<span class="nc" id="L316">                case &quot;cos&quot;:   return new RealValue(c.cos  (toDouble(root.left.value)), 10);</span>
<span class="nc" id="L317">                case &quot;tan&quot;:   return new RealValue(c.tan  (toDouble(root.left.value)), 10);</span>
<span class="nc" id="L318">                case &quot;E&quot;:     return new RealValue(Math.pow(10, toDouble(root.left.value)), 10);</span>

                case &quot;exp&quot;:
<span class="nc" id="L321">                    Exp exp = new Exp(List.of(new MyNumber(evaluate(root.left))), Notation.PREFIX);</span>
<span class="nc" id="L322">                    NumericValue expResult = exp.op(new RealValue(Double.parseDouble(evaluate(root.left).toString()),10));</span>
<span class="nc" id="L323">                    return new RealValue(Double.parseDouble(expResult.toString()),10);</span>

                // Fonctions unaires MyNumber
                case &quot;ln&quot;:
<span class="nc" id="L327">                    Ln ln = new Ln(List.of(new MyNumber(evaluate(root.left))), Notation.INFIX);</span>
<span class="nc" id="L328">                    return new RealValue(Double.parseDouble(c.eval(ln).toString()),10);</span>

<span class="fc" id="L330">                case &quot;sqrt&quot;:  return new RealValue(Math.sqrt(Double.parseDouble(evaluate(root.left).toString())),10);</span>
                case &quot;inv&quot;:
<span class="nc" id="L332">                    Inverse inv = new Inverse(List.of(new MyNumber(evaluate(root.left))), Notation.INFIX);</span>
<span class="nc" id="L333">                    return new RealValue(Double.parseDouble(c.eval(inv).toString()),10);</span>
                // Pourcentage
                case &quot;%&quot;:
<span class="fc" id="L336">                    NumericValue pct = evaluate(root.left);</span>
                    // diviser par 100 : équivalent à MyNumber.divide(100)
<span class="fc" id="L338">                    return pct.divide(new RealValue(BigDecimal.valueOf(100), 10));</span>
                default:
<span class="nc" id="L340">                    throw new IllegalArgumentException(&quot;Fonction inconnue: &quot; + root.value);</span>
            }
        }

<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (root.isComplex) {</span>
<span class="nc" id="L345">            return parseComplex(root.value);</span>
        }

<span class="pc bpc" id="L348" title="1 of 4 branches missed.">        if (root.left == null &amp;&amp; root.right == null) {</span>

<span class="fc" id="L350">            return new RealValue(new BigDecimal(root.value), 10);</span>
        }

<span class="fc" id="L353">        NumericValue leftVal = evaluate(root.left);</span>
<span class="fc" id="L354">        NumericValue rightVal = evaluate(root.right);</span>

<span class="pc bpc" id="L356" title="1 of 5 branches missed.">        switch (root.value) {</span>
<span class="fc" id="L357">            case &quot;+&quot;: return leftVal.add(rightVal);</span>
<span class="fc" id="L358">            case &quot;-&quot;: return leftVal.subtract(rightVal);</span>
<span class="fc" id="L359">            case &quot;*&quot;: return leftVal.multiply(rightVal);</span>
            case &quot;/&quot;:
            {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">                if(ExpressionParser.getDisplay()== ExpressionParser.Display.FRACTION)</span>
<span class="nc" id="L363">                    return new RationalValue(new BigInteger(leftVal.toString()),new BigInteger(rightVal.toString()));</span>
                else
<span class="fc" id="L365">                    return leftVal.divide(rightVal);</span>

            }
<span class="nc" id="L368">            default: throw new IllegalArgumentException(&quot;Invalid operator: &quot; + root.value);</span>
        }
    }

    /** Parses a complex number literal of the form [a+bi] */
    private static NumericValue parseComplex(String value) {
<span class="nc" id="L374">        String inside = value.substring(1, value.length() - 1);</span>
<span class="nc" id="L375">        inside = inside.replace(&quot;i&quot;, &quot;&quot;);</span>
<span class="nc" id="L376">        String realPart = &quot;0&quot;, imagPart = &quot;0&quot;;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (inside.contains(&quot;+&quot;)) {</span>
<span class="nc" id="L378">            String[] parts = inside.split(&quot;\\+&quot;);</span>
<span class="nc" id="L379">            realPart = parts[0];</span>
<span class="nc" id="L380">            imagPart = parts[1];</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        } else if (inside.contains(&quot;-&quot;)) {</span>
<span class="nc" id="L382">            int idx = inside.lastIndexOf('-');</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (idx == 0) {</span>
<span class="nc" id="L384">                inside = inside.substring(1);</span>
<span class="nc" id="L385">                idx = inside.indexOf('-');</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (idx == -1) {</span>
<span class="nc" id="L387">                    realPart = &quot;-&quot; + inside;</span>
<span class="nc" id="L388">                    imagPart = &quot;0&quot;;</span>
                } else {
<span class="nc" id="L390">                    realPart = &quot;-&quot; + inside.substring(0, idx);</span>
<span class="nc" id="L391">                    imagPart = inside.substring(idx);</span>
                }
            } else {
<span class="nc" id="L394">                realPart = inside.substring(0, idx);</span>
<span class="nc" id="L395">                imagPart = inside.substring(idx);</span>
            }
<span class="nc" id="L397">        } else {</span>
<span class="nc" id="L398">            imagPart = inside;</span>
        }
<span class="nc" id="L400">        return new ComplexValue(Double.parseDouble(realPart), Double.parseDouble(imagPart));</span>
    }

    /**
     * Entry point to test infix expressions.
     */
    public static void main(String[] args) {
<span class="nc" id="L407">        ExpressionParser.mycalculator.setUseRadians(false);</span>
<span class="nc" id="L408">        String expr = &quot;1.8 * E(2)&quot;;</span>
        try {
<span class="nc" id="L410">            Node root = buildTree(expr);</span>
<span class="nc" id="L411">            NumericValue result = evaluate(root);</span>
<span class="nc" id="L412">            System.out.println(&quot;Résultat: &quot; + result);</span>
<span class="nc" id="L413">        } catch (Exception e) {</span>
<span class="nc" id="L414">            System.err.println(&quot;Erreur: &quot; + e.getMessage());</span>
<span class="nc" id="L415">        }</span>
<span class="nc" id="L416">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>